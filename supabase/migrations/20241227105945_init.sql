--
-- For use with https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone
--

-- Custom types
create type public.app_permission as enum ('todos.read', 'todos.update', 'todos.delete');
create type public.app_role as enum ('admin', 'moderator');
create type public.user_status as enum ('ONLINE', 'OFFLINE');
create type public.visibility as enum ('public', 'private');
create type public.todo_status as enum ('PROGRESS', 'COMPLETED', 'CANCELLED');

-- USERS
create table public.users (
  id          uuid references auth.users not null primary key,
  username    text unique,
  email       text unique,
  status      user_status default 'OFFLINE'::public.user_status,
  full_name   text,
  avatar_url  text,
  website     text,
  is_admin    boolean default false,
  created_at  timestamp with time zone default timezone('utc'::text, now()),
  updated_at  timestamp with time zone default timezone('utc'::text, now())
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- TODOS
create table public.todos (
  id            uuid default uuid_generate_v4() primary key,
  title         text not null unique,
  description   text,
  status        todo_status default 'PROGRESS'::public.todo_status,
  visibility    visibility default 'private',
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  created_by    uuid references public.users not null,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table public.todos is 'Todos data for each user.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- Secure the tables
alter table public.users enable row level security;
alter table public.todos enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
create policy "Allow logged-in read access" on public.users for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.users for insert with check ( auth.uid() = id );
create policy "Allow individual update access" on public.users for update using ( auth.uid() = id );
create policy "Allow individual read access" on public.user_roles for select using ( auth.uid() = user_id );

create policy "Allow logged-in read access" on public.todos for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.todos for insert with check ( auth.uid() = created_by );
create policy "Allow individual delete access" on public.todos for delete using ( auth.uid() = created_by );
create policy "Allow authorized read access" on public.todos for delete using ( authorize('todos.read') );
create policy "Allow authorized update access" on public.todos for delete using ( authorize('todos.update') );
create policy "Allow authorized delete access" on public.todos for delete using ( authorize('todos.delete') );

-- Send "previous data" on change 
alter table public.users replica identity full; 
alter table public.todos replica identity full; 

-- inserts a row into public.users and assigns roles
create function public.handle_new_user() 
returns trigger as $$
declare user_count integer;
begin
    select count(*) from public.users into user_count;

    insert into public.users (id, username, full_name, avatar_url, is_admin)
    values (
        new.id,
        COALESCE(new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'email'),
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url',
        user_count = 0
    );
    
    -- If this is the first user (count = 1), make them admin, otherwise moderator
    if user_count = 0 then
        insert into public.user_roles (user_id, role) values (new.id, 'admin');
    else
        insert into public.user_roles (user_id, role) values (new.id, 'moderator');
    end if;
    
    return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

begin; 
  -- remove the realtime publication
  drop publication if exists supabase_realtime; 

  -- re-create the publication but don't enable it for any tables
  create publication supabase_realtime;  
commit;

-- add tables to the publication
-- alter publication supabase_realtime add table public.todos;
alter publication supabase_realtime add table public.users;


-- HELPER FUNCTIONS
-- Create test user helper method.
create or replace function public.create_user(
    email text
) returns uuid
    security definer
    set search_path = auth
as $$
  declare
  user_id uuid;
begin
  user_id := extensions.uuid_generate_v4();
  
  insert into auth.users (id, email)
    values (user_id, email)
    returning id into user_id;

    return user_id;
end;
$$ language plpgsql;