--
-- For use with https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone
--

-- Custom types
create type public.app_permission as enum (
  'todos.read', 
  'todos.update', 
  'todos.delete',
  'teams.read', 
  'teams.update', 
  'teams.delete'
);

-- Add team team role type
create type public.app_role as enum ('OWNER', 'ADMIN', 'MEMBER');
-- Add team user status type
create type public.user_status as enum ('ONLINE', 'OFFLINE');
-- Add todo status type
create type public.todo_status as enum ('PROGRESS', 'COMPLETED', 'CANCELLED');
-- Add team invitation status type
create type public.invitation_status as enum ('PENDING', 'ACCEPTED', 'REJECTED');
-- Add team visibility type
create type public.team_visibility as enum ('PUBLIC', 'PRIVATE');

-- Add audit fields helper function
create or replace function trigger_set_timestamp()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- USERS
create table public.users (
  id          uuid references auth.users not null primary key,
  username    text unique,
  email       text unique,
  status      user_status default 'OFFLINE'::public.user_status,
  full_name   text,
  avatar_url  text,
  website     text,
  is_superadmin boolean default false,
  created_at  timestamp with time zone default timezone('utc'::text, now()),
  updated_at  timestamp with time zone default timezone('utc'::text, now())
);

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';


-- TEAMS
create table public.teams (
  id              uuid default uuid_generate_v4() primary key,
  name            text not null,
  slug            text unique not null,
  description     text,
  visibility      team_visibility default 'PRIVATE',
  avatar_url      text,
  metadata        jsonb default '{}',
  created_by      uuid references public.users not null,
  created_at      timestamp with time zone default timezone('utc'::text, now()),
  updated_at      timestamp with time zone default timezone('utc'::text, now())
);

-- TEAM MEMBERS
create table public.team_members (
  id              uuid default uuid_generate_v4() primary key,
  team_id         uuid references public.teams on delete cascade,
  user_id         uuid references public.users on delete cascade,
  role            app_role not null default 'MEMBER',
  status          invitation_status default 'PENDING',
  invite_email    text,
  invited_by      uuid references public.users,
  joined_at       timestamp with time zone,
  metadata        jsonb default '{}',
  created_at      timestamp with time zone default timezone('utc'::text, now()),
  updated_at      timestamp with time zone default timezone('utc'::text, now()),
  unique (team_id, user_id),
  unique (team_id, invite_email)
);

-- TEAM AUDIT
create table public.team_audit_log (
  id              uuid default uuid_generate_v4() primary key,
  team_id         uuid references public.teams on delete cascade,
  user_id         uuid references public.users,
  action          text not null,
  details         jsonb default '{}',
  created_at      timestamp with time zone default timezone('utc'::text, now())
);

-- TODOS
create table public.todos (
  id            bigint generated by default as identity primary key,
  title         text not null unique,
  description   text,
  status        todo_status default 'PROGRESS'::public.todo_status,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  created_by    uuid references public.users not null,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table public.todos is 'Todo data for each user.';

-- Add updated timestamps trigger to tables
create trigger set_timestamp
before update on public.teams
for each row execute function trigger_set_timestamp();

create trigger set_timestamp
before update on public.team_members
for each row execute function trigger_set_timestamp();

-- Function to create a new team
create or replace function public.create_team(
  team_name text,
  team_slug text,
  team_description text default null,
  team_visibility team_visibility default 'PRIVATE'
)
returns uuid as $$
declare
  new_team_id uuid;
begin
  -- Insert the team
  insert into public.teams (name, slug, description, visibility, created_by)
  values (team_name, team_slug, team_description, team_visibility, auth.uid())
  returning id into new_team_id;
  
  -- Add creator as OWNER
  insert into public.team_members (
    team_id, 
    user_id, 
    role, 
    status, 
    joined_at
  )
  values (
    new_team_id, 
    auth.uid(), 
    'OWNER', 
    'ACCEPTED', 
    now()
  );
  
  -- Log the creation
  insert into public.team_audit_log (team_id, user_id, action, details)
  values (
    new_team_id, 
    auth.uid(), 
    'team.created',
    jsonb_build_object(
      'name', team_name,
      'visibility', team_visibility
    )
  );
  
  return new_team_id;
end;
$$ language plpgsql security definer;

-- Function to invite a member to a team
create or replace function public.invite_team_member(
  team_id uuid,
  email text,
  role app_role default 'MEMBER'
)
returns uuid as $$
declare
  invite_id uuid;
  existing_user_id uuid;
begin
  -- Check if inviter has permission
  if not authorize('teams.update', auth.uid(), team_id) then
    raise exception 'Unauthorized to invite members to this team';
  end if;
  
  -- Check if user already exists
  select id into existing_user_id
  from public.users
  where lower(username) = lower(email);
  
  -- Create invitation
  insert into public.team_members (
    team_id,
    user_id,
    invite_email,
    role,
    invited_by
  )
  values (
    team_id,
    existing_user_id,
    case when existing_user_id is null then email else null end,
    role,
    auth.uid()
  )
  returning id into invite_id;
  
  -- Log the invitation
  insert into public.team_audit_log (team_id, user_id, action, details)
  values (
    team_id,
    auth.uid(),
    'member.invited',
    jsonb_build_object(
      'invited_email', email,
      'role', role
    )
  );
  
  return invite_id;
end;
$$ language plpgsql security definer;

-- Function to accept team invitation
create or replace function public.accept_team_invitation(
  team_id uuid
)
returns boolean as $$
declare
  invite_record record;
begin
  -- Find and validate invitation
  select * into invite_record
  from public.team_members
  where team_id = accept_team_invitation.team_id
    and (user_id = auth.uid() or lower(invite_email) = lower(auth.email()))
    and status = 'PENDING';
    
  if not found then
    raise exception 'No pending invitation found';
  end if;
  
  -- Accept invitation
  update public.team_members
  set 
    status = 'ACCEPTED',
    user_id = auth.uid(),
    joined_at = now(),
    invite_email = null
  where id = invite_record.id;
  
  -- Log the acceptance
  insert into public.team_audit_log (team_id, user_id, action)
  values (team_id, auth.uid(), 'member.joined');
  
  return true;
end;
$$ language plpgsql security definer;



-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as
$$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$
language plpgsql security definer;



-- Secure the tables
alter table public.users
  enable row level security;
alter table public.user_roles
  enable row level security;
alter table public.role_permissions
  enable row level security;
alter table public.teams
  enable row level security;
alter table public.teams_members
  enable row level security;
alter table public.todos
  enable row level security;

-- Users policies
create policy "Allow logged-in read access" on public.users
  for select using (auth.role() = 'authenticated');

create policy "Allow individual insert access" on public.users
  for insert with check (auth.uid() = id);

create policy "Allow individual update access" on public.users
  for update using (auth.uid() = id);

-- Users role policies
create policy "Allow individual read access" on public.user_roles
  for select using ((select auth.uid()) = user_id);

-- Users team policies
create policy "Allow individual read access" on public.teams
  for select using ((select auth.uid()) = created_by);

-- Users team member policies
create policy "Allow individual read access" on public.team_members
  for select using ((select auth.uid()) = user_id);


-- Todos policies
create policy "Allow individual read access" on public.todos
  for select using (
    auth.uid() = created_by 
    or
    authorize('todos.read'::app_permission, auth.uid())
  );

create policy "Allow individual insert access" on public.todos
  for insert with check (auth.uid() = created_by);

create policy "Allow individual delete access" on public.todos
  for delete using (
    auth.uid() = created_by 
    or
    authorize('todos.delete'::app_permission, auth.uid())
  );

create policy "Allow authorized update access" on public.todos
  for update using (
    auth.uid() = created_by 
    or
    authorize('todos.update'::app_permission, auth.uid())
  );


-- Send "previous data" on change
alter table public.users
  replica identity full;
alter table public.todos
  replica identity full;
alter table public.teams
  replica identity full;
alter table public.team_members
  replica identity full;

-- inserts a row into public.users and assigns roles
create or replace function public.handle_new_user()
  returns trigger
  security definer
  set search_path = ''
  as $$
  declare
    is_first_user boolean;
    new_role app_role;
    team_member_role app_role;
  begin
    -- Check if the user is the first user
    select count(*) = 0 into is_first_user
    from public.users;

    -- Set the role based on whether this is the first user
    new_role := case
      when is_first_user then 'SUPERADMIN'::app_role  -- First user gets SUPERADMIN role
      else 'ADMIN'::app_role  -- All other users get MEMBER role
    end;

    -- Insert new user
    insert into public.users (
      id,
      username,
      full_name,
      avatar_url,
      is_superadmin
    )
    values (
      new.id,
      COALESCE(new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'email'),
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'avatar_url',
      is_first_user -- First user becomes superadmin
    );

    -- Insert the role for the new user (default role)
    insert into public.user_roles (user_id, role)
    values (new.id, new_role);

    -- Check if the user is invited to a team and assign the team role
    select role into team_member_role
    from public.team_members
    where invite_email = lower(new.email)
      and user_id is null
      and status = 'PENDING'
    limit 1;

    -- If the user is invited to a team, add the team role to the user's roles
    if found then
      insert into public.user_roles (user_id, role)
      values (new.id, team_member_role);
      
      -- Update the team member record to link the user
      update public.team_members
      set user_id = new.id
      where invite_email = lower(new.email)
        and user_id is null
        and status = 'PENDING';
    end if;

    -- Update pending team invitations for the new user
    update public.team_members
    set user_id = new.id
    where user_id is null
      and lower(new.email) = lower(invite_email)
      and status = 'PENDING';

    return new;
  end;
$$ language plpgsql security definer;


-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

-- begin;
--   remove the realtime publication
--   drop publication if exists supabase_realtime;

-- re-create the publication but don't enable it for any tables
-- create publication supabase_realtime;
-- commit;

-- add tables to the publication
-- alter publication supabase_realtime add table public.todos;
-- alter publication supabase_realtime add table public.users;

-- DUMMY DATA
-- insert into public.users (id, username)
-- values
--     ('8d0fd2b3-9ca7-4d9e-a95f-9e13dded323e', 'supabot');

-- insert into public.channels (slug, created_by)
-- values
--     ('public', '8d0fd2b3-9ca7-4d9e-a95f-9e13dded323e'),
--     ('random', '8d0fd2b3-9ca7-4d9e-a95f-9e13dded323e');

-- insert into public.messages (message, channel_id, user_id)
-- values
--     ('Hello World ðŸ‘‹', 1, '8d0fd2b3-9ca7-4d9e-a95f-9e13dded323e'),
--     ('Perfection is attained, not when there is nothing more to add, but when there is nothing left to take away.', 2, '8d0fd2b3-9ca7-4d9e-a95f-9e13dded323e');

-- Insert default team role permissions
insert into public.app_role_permissions (role, permission) values
  -- Owner has all permissions
  ('OWNER', 'todos.read'),
  ('OWNER', 'todos.update'),
  ('OWNER', 'todos.delete'),
  ('OWNER', 'teams.read'),
  ('OWNER', 'teams.update'),
  ('OWNER', 'teams.delete'),
  -- Admin has most permissions
  ('ADMIN', 'todos.read'),
  ('ADMIN', 'todos.update'),
  ('ADMIN', 'todos.delete'),
  ('ADMIN', 'teams.read'),
  ('ADMIN', 'teams.update'),
  -- Member has basic permissions
  ('MEMBER', 'todos.read'),
  ('MEMBER', 'todos.update'),
  ('MEMBER', 'teams.read');


-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');